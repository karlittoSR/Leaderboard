<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elden Ring – Any% Glitchless: Top 10 (Canvas)</title>
  <style>
    :root { --muted:#94a3b8; --text:#e2e8f0; }
    html, body { height: 100%; margin: 0; }
    body {
      background: transparent; /* twitch/karlitto__ */
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid; place-items: start; padding: 8px;
    }
    canvas { display:block; width:900px; height:174px; }
  </style>
</head>
<body>
  <canvas id="board" width="1200" height="400"></canvas>
  <script>
    // === Chargement Configuration ===
    // Variables chargees depuis config.json
    let GAME_ID;
    let CATEGORY_NAME;
    let SUBCATEGORY_LABEL;
    let SUBCATEGORIES;
    let LEVEL_ID;
    let LEVEL_NAME;
    let PLAYER_NAME;
    let CAROUSEL_INTERVAL;
    let RUNS_PER_BATCH;
    let TOP_COUNT;

    async function loadConfig() {
      try {
        // Charger config.json
        const configRes = await fetch('config.json');
        if (!configRes.ok) {
          throw new Error(`Impossible de charger config.json (HTTP ${configRes.status})`);
        }
        const config = await configRes.json();
        
        // Obtenir le preset actif depuis config.json (plus besoin de parametre URL)
        const presetName = config.activePreset;
        if (!presetName) {
          throw new Error('Aucun preset actif défini dans config.json. Utilisez le script PowerShell pour en définir un.');
        }
        
        const preset = config.presets[presetName];
        if (!preset) {
          const availablePresets = Object.keys(config.presets);
          throw new Error(`Preset actif "${presetName}" non trouvé. Options disponibles : ${availablePresets.join(', ')}`);
        }

        // Appliquer les parametres du preset
        GAME_ID = preset.gameId;
        CATEGORY_NAME = preset.category;
        SUBCATEGORY_LABEL = preset.subcategory;
        SUBCATEGORIES = preset.subcategories || null;
        if (SUBCATEGORIES && !Array.isArray(SUBCATEGORIES)) {
          SUBCATEGORIES = [SUBCATEGORIES];
        }
        LEVEL_ID = preset.levelId || null;
        LEVEL_NAME = preset.levelName || null;
        PLAYER_NAME = (config.playerName || '').trim();
        if (PLAYER_NAME === '') PLAYER_NAME = null;

        // Appliquer les valeurs par defaut depuis config.json
        const defaults = config.defaults;
        CAROUSEL_INTERVAL = defaults.carouselInterval;
        CAROUSEL_DISPLAY_DURATION = CAROUSEL_INTERVAL - CAROUSEL_FADE_DURATION - CAROUSEL_FADE_DURATION;
        RUNS_PER_BATCH = defaults.runsPerBatch;
        TOP_COUNT = defaults.topCount;

        // Mettre a jour le titre
        document.title = preset.name + ': Top ' + TOP_COUNT + ' (Canvas)';

        // Mettre a jour la taille du canvas depuis les defaults
        canvas.width = defaults.canvasWidth;
        canvas.height = defaults.canvasHeight;
        canvas.style.width = defaults.displayWidth;
        canvas.style.height = defaults.displayHeight;

        // Demarrer le chargement des donnees
        loadTop();
      } catch (e) {
        console.error('Erreur de configuration :', e);
        document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">❌ Erreur : ${e.message}</div>`;
      }
    }

    // === Canvas Setup ===
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    // Drawing constants
    const DRAW = {
      FLAG: { w: 20, h: 15, yOffset: 14, radius: 5 },
      MEDAL: { w: 15, h: 15, yOffset: 14, spacing: 2 },
      LAYOUT: { padX: 12, startY: 30, rowH: 24 },
      FONT_BASE: '700 18px Arial, sans-serif',
      FONT_MONO: '700 18px Arial, sans-serif, SFMono-Regular, Menlo, Consolas, "Liberation Mono"',
      SHADOW: { color: 'rgba(0,0,0,0.6)', blur: 6, offsetY: 2 },
      COLORS: { top1: '#ffd700', top2: '#c0c0c0', top3: '#cd7f32', other: '#9fb4ca' }
    };

    // Image caches
    const imageCache = {
      flags: new Map()
    };

    // État du carousel
    let carouselPage = 0;
    let carouselRuns = [];
    let carouselInterval = null;
    let carouselStartTime = 0;
    let carouselPhase = 'display'; // 'display', 'fadeOut', 'fadeIn'
    let CAROUSEL_FADE_DURATION = 500; // Durée de transition fade (ms)
    let CAROUSEL_DISPLAY_DURATION = 3000; // Durée d'affichage (calculée dans loadConfig)

    let fixedMaxRankW = 0;
    let fixedMaxNameBlock = 0;
    let processedTopRuns = [];
    async function loadImage(url, cache, timeout = 5000) {
      if (!url) return null;
      if (cache.has(url)) return cache.get(url);
      
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        const timeoutId = setTimeout(() => {
          resolve(null);
        }, timeout);
        
        img.onload = () => {
          clearTimeout(timeoutId);
          cache.set(url, img);
          resolve(img);
        };
        
        img.onerror = () => {
          clearTimeout(timeoutId);
          resolve(null);
        };
        
        img.src = url;
      });
    }

    function loadFlagImage(code) {
      if (!code) return Promise.resolve(null);
      const url = `https://flagcdn.com/w40/${code.toLowerCase()}.png`;
      return loadImage(url, imageCache.flags);
    }

    // === Utilities ===
    function drawRoundedImage(img, x, y, w, h, r) {
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x, y, w, h);
      ctx.restore();
    }

    function formatTime(sec) {
      const total = Math.round(sec * 1000) / 1000;
      const h = Math.floor(total / 3600), m = Math.floor((total % 3600) / 60), s = Math.floor(total % 60);
      const mm = String(m).padStart(2, '0'), ss = String(s).padStart(2, '0');
      return h > 0 ? `${h}:${mm}:${ss}` : `${m}:${ss}`;
    }

    function getRankColor(position) {
      return [DRAW.COLORS.top1, DRAW.COLORS.top2, DRAW.COLORS.top3, DRAW.COLORS.other][Math.min(position, 3)];
    }

    function truncatePlayer(name, maxChars = 15) {
      return name.length > maxChars ? name.substring(0, maxChars) + '.' : name;
    }

    function applyTextStyle(x, y, text, style) {
      if (!style || style.style === 'solid') {
        ctx.fillStyle = style?.color?.dark || style?.color?.light || '#e2e8f0';
        return;
      }
      if (style.style === 'gradient') {
        const from = style['color-from']?.dark || '#e2e8f0';
        const to = style['color-to']?.dark || '#e2e8f0';
        const width = ctx.measureText(text).width;
        const grad = ctx.createLinearGradient(x, y, x + width, y);
        grad.addColorStop(0, from);
        grad.addColorStop(1, to);
        ctx.fillStyle = grad;
        return;
      }
      ctx.fillStyle = '#e2e8f0';
    }

    function hslToRgb(h, s, l) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;

      if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
      else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
      else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
      else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
      else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }

      const rr = Math.round((r + m) * 255);
      const gg = Math.round((g + m) * 255);
      const bb = Math.round((b + m) * 255);
      return `rgb(${rr}, ${gg}, ${bb})`;
    }

    function applyRainbowText(x, y, text, phase, alpha = 1) {
      const width = ctx.measureText(text).width || 1;
      const grad = ctx.createLinearGradient(x, y, x + width, y);
      const stops = 6;
      for (let i = 0; i <= stops; i++) {
        const t = i / stops;
        const hue = (phase + t * 360) % 360;
        grad.addColorStop(t, hslToRgb(hue, 0.5, 0.7));
      }
      ctx.globalAlpha = alpha;
      ctx.fillStyle = grad;
    }

    // === Draw ===
    function draw(topRuns, carouselBatch, fadeProgress = 1, playerRow = null) {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx.shadowColor = DRAW.SHADOW.color;
      ctx.shadowBlur = DRAW.SHADOW.blur;
      ctx.shadowOffsetY = DRAW.SHADOW.offsetY;
      ctx.font = DRAW.FONT_BASE;
      ctx.textAlign = 'left';

      const allDisplay = [...topRuns, ...carouselBatch];
      const { padX, startY, rowH } = DRAW.LAYOUT;
      const colRank = padX;
      const timeX = 300; // Right aligned

      for (let i = 0; i < allDisplay.length; i++) {
        const r = allDisplay[i];
        const y = startY + i * rowH;
        const color = getRankColor(i);

        // Apply fade only to carousel rows (rows 3-7, indices 3-7)
        const isCarouselRow = i >= TOP_COUNT;
        const globalAlpha = ctx.globalAlpha;
        if (isCarouselRow && fadeProgress < 1) {
          ctx.globalAlpha = fadeProgress;
        }

        // Draw rank number
        ctx.fillStyle = color;
        ctx.textAlign = 'left';
        const rankText = (typeof r.rank === 'number' && r.rank > 0) ? `#${r.rank}` : `${r.rank}`;
        ctx.fillText(rankText, colRank, y);

        // Draw flag + name
        let x = colRank + fixedMaxRankW + 3;
        if (r.flagImg) {
          drawRoundedImage(r.flagImg, x, y - DRAW.FLAG.yOffset, DRAW.FLAG.w, DRAW.FLAG.h, DRAW.FLAG.radius);
          x += DRAW.FLAG.w + 4;
        }

        const displayName = truncatePlayer(r.player);
        ctx.fillStyle = color;
        
        applyTextStyle(x, y, displayName, r.nameStyle);
        ctx.textAlign = 'left';
        ctx.fillText(displayName, x, y);

        // Draw time (right-aligned)
        ctx.font = DRAW.FONT_MONO;
        ctx.fillStyle = color;
        
        ctx.textAlign = 'right';
        ctx.fillText(r.time, timeX, y);

        ctx.globalAlpha = globalAlpha;
      }

      if (playerRow) {
        const gap = rowH; // One clear blank row
        const canvasH = canvas.clientHeight;
        const desiredY = startY + allDisplay.length * rowH + gap;
        const y = Math.min(desiredY, canvasH - rowH);
        const phase = (Date.now() / 30) % 360;

        ctx.textAlign = 'left';
        const rankText = (typeof playerRow.rank === 'number' && playerRow.rank > 0) ? `#${playerRow.rank}` : `${playerRow.rank}`;
        applyRainbowText(colRank, y, rankText, phase);
        ctx.fillText(rankText, colRank, y);

        let x = colRank + fixedMaxRankW + 3;
        if (playerRow.flagImg) {
          drawRoundedImage(playerRow.flagImg, x, y - DRAW.FLAG.yOffset, DRAW.FLAG.w, DRAW.FLAG.h, DRAW.FLAG.radius);
          x += DRAW.FLAG.w + 4;
        }

        const displayName = truncatePlayer(playerRow.player);
        applyRainbowText(x, y, displayName, phase + 40);
        ctx.textAlign = 'left';
        ctx.fillText(displayName, x, y);

        ctx.font = DRAW.FONT_MONO;
        applyRainbowText(timeX - ctx.measureText(playerRow.time).width, y, playerRow.time, phase + 80);
        ctx.textAlign = 'right';
        ctx.fillText(playerRow.time, timeX, y);
        ctx.globalAlpha = 1;
      }

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
    }

    // === Traitement des donnees ===
    async function fetchJSON(url, timeout = 10000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const r = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (!r.ok) throw new Error(`HTTP ${r.status} pour ${url}`);
        return r.json();
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          throw new Error(`Delai d'attente depasse (${timeout}ms) pour ${url}`);
        }
        throw error;
      }
    }

    async function resolveCategoryAndVariable() {
      const url = `https://www.speedrun.com/api/v1/games/${GAME_ID}?embed=categories.variables`;
      const data = await fetchJSON(url);
      const cats = data.data.categories.data;
      const targetType = LEVEL_ID ? 'per-level' : 'per-game';
      const cat = cats.find(c => c.type === targetType && c.name === CATEGORY_NAME);
      if (!cat) throw new Error(`Categorie "${CATEGORY_NAME}" non trouvee (options : ${cats.map(c => c.name).join(', ')})`);
      
      // Nouvelle structure: liste d'IDs des sous-categories
      if (Array.isArray(SUBCATEGORIES) && SUBCATEGORIES.length > 0) {
        const variablePairs = SUBCATEGORIES
          .filter(s => s && s.variableId && s.valueId)
          .map(s => ({ variableId: s.variableId, valueId: s.valueId }));
        return { categoryId: cat.id, variablePairs };
      }

      // Si pas de sous-categorie requis
      if (!SUBCATEGORY_LABEL) {
        return { categoryId: cat.id, variablePairs: [] };
      }

      const vars = (cat.variables?.data) || [];
      const labels = SUBCATEGORY_LABEL.split(' - ').map(s => s.trim()).filter(Boolean);
      const usedVars = new Set();
      const variablePairs = [];

      for (const label of labels) {
        const sub = vars.find(v => v['is-subcategory'] && v.values?.values && !usedVars.has(v.id) &&
          Object.values(v.values.values).some(val => val.label.toLowerCase() === label.toLowerCase()));
        if (!sub) throw new Error(`Sous-categorie "${label}" non trouvee pour "${CATEGORY_NAME}"`);

        const entry = Object.entries(sub.values.values)
          .find(([, value]) => value.label.toLowerCase() === label.toLowerCase());
        if (!entry) throw new Error(`Valeur "${label}" non trouvee`);

        const [valueId] = entry;
        variablePairs.push({ variableId: sub.id, valueId });
        usedVars.add(sub.id);
      }

      return { categoryId: cat.id, variablePairs };
    }

    function calculateColumnWidths(allRuns, playerRow) {
      ctx.font = DRAW.FONT_BASE;
      
      let maxRankW = 0;
      let maxNameBlock = 0;

      const widthRuns = playerRow ? [...allRuns, playerRow] : allRuns;
      for (const r of widthRuns) {
        // Largeur du numero de rang
        const isNumericRank = typeof r.rank === 'number' && r.rank >= 1 && r.rank <= 3;
        const rankText = (typeof r.rank === 'number' && r.rank > 0) ? `#${r.rank}` : `${r.rank}`;
        const rankW = isNumericRank
          ? (DRAW.MEDAL.w + DRAW.MEDAL.spacing)
          : ctx.measureText(rankText).width;
        maxRankW = Math.max(maxRankW, rankW);

        // Largeur du bloc nom (drapeau + nom tronque)
        const flagW = r.flagImg ? DRAW.FLAG.w + 4 : 0;
        const truncatedName = truncatePlayer(r.player);
        const nameW = ctx.measureText(truncatedName).width;
        maxNameBlock = Math.max(maxNameBlock, flagW + nameW);
      }

      fixedMaxRankW = maxRankW;
      fixedMaxNameBlock = maxNameBlock;
    }

    async function loadTop() {
      try {
        const { categoryId, variablePairs } = await resolveCategoryAndVariable();
        
        // Build leaderboard URL
        let lbUrl;
        if (LEVEL_ID) {
          lbUrl = `https://www.speedrun.com/api/v1/leaderboards/${GAME_ID}/level/${LEVEL_ID}/${categoryId}?top=100&embed=players`;
        } else {
          lbUrl = `https://www.speedrun.com/api/v1/leaderboards/${GAME_ID}/category/${categoryId}?top=100&embed=players`;
        }
        if (Array.isArray(variablePairs) && variablePairs.length > 0) {
          for (const pair of variablePairs) {
            if (pair.variableId && pair.valueId) {
              lbUrl += `&var-${pair.variableId}=${pair.valueId}`;
            }
          }
        }
        
        const lb = await fetchJSON(lbUrl);

        // Construire la carte des joueurs
        const playerMap = new Map();
        if (lb.data.players?.data) {
          for (const player of lb.data.players.data) {
            const displayName = player.rel === 'guest' ? player.name : (player.names?.international || player.id);
            playerMap.set(player.id, {
              name: displayName,
              style: player['name-style'] || null,
              country: player.location?.country?.code || null
            });
          }
        }

        // Traiter les runs
        const allRuns = (lb.data.runs || []).map((entry) => {
          const run = entry.run;
          const players = (run.players || []).map((p) => {
            if (p.rel === 'guest') return p.name;
            const info = playerMap.get(p.id);
            return info ? info.name : p.id;
          });

          const firstPlayer = run.players?.[0];
          const playerInfo = firstPlayer && firstPlayer.rel !== 'guest'
            ? (playerMap.get(firstPlayer.id) || { name: players[0] || 'Inconnu', style: null, country: null })
            : { name: players[0] || 'Inconnu', style: null, country: null };

          return {
            rank: entry.place || 0,
            player: playerInfo.name,
            players,
            nameStyle: playerInfo.style,
            country: playerInfo.country,
            time: formatTime(run.times?.primary_t || 0),
            submitted: run.submitted
          };
        });

        let playerRow = null;
        if (PLAYER_NAME) {
          const target = PLAYER_NAME.toLowerCase();
          const match = allRuns.find(r => (r.players || []).some(n => n.toLowerCase() === target));
          if (match) {
            playerRow = { ...match, player: PLAYER_NAME };
          }
        }

        // Diviser en TOP N et carousel
        const topRuns = allRuns.slice(0, TOP_COUNT);
        carouselRuns = allRuns.slice(TOP_COUNT, 100);
        carouselPage = 0;

        // Charger les images des drapeaux
        const countryCodes = Array.from(new Set(allRuns.map(r => r.country).filter(Boolean)));
        await Promise.allSettled(countryCodes.map(loadFlagImage));
        
        const flagMap = new Map();
        for (const code of countryCodes) {
          const key = code.toLowerCase();
          const flagUrl = `https://flagcdn.com/w40/${key}.png`;
          flagMap.set(code, imageCache.flags.get(flagUrl) || null);
        }
        console.log(`Drapeaux charges : ${countryCodes.length}`);

        const processRuns = (runs) => runs.map(r => ({
          ...r,
          flagImg: flagMap.get(r.country) || null
        }));

        const processedTop = processRuns(topRuns);
        carouselRuns = processRuns(carouselRuns);
        const processedPlayerRow = playerRow ? {
          ...playerRow,
          flagImg: flagMap.get(playerRow.country) || null
        } : null;

        // Stocker pour le carousel
        processedTopRuns = processedTop;

        // Calculate fixed widths
        calculateColumnWidths(allRuns, processedPlayerRow);

        // Draw and start carousel
        const availableRows = Math.floor((canvas.clientHeight - DRAW.LAYOUT.startY) / DRAW.LAYOUT.rowH);
        const extraRows = processedPlayerRow ? 2 : 0; // blank row + player row
        const neededRows = TOP_COUNT + RUNS_PER_BATCH + extraRows;
        const overflow = Math.max(0, neededRows - availableRows);
        const displayRunsPerBatch = Math.max(0, RUNS_PER_BATCH - overflow);
        const firstBatch = displayRunsPerBatch > 0 ? carouselRuns.slice(0, displayRunsPerBatch) : [];
        draw(processedTop, firstBatch, 1, processedPlayerRow);

        if (carouselRuns.length > 0 && displayRunsPerBatch > 0) {
          if (carouselInterval) clearInterval(carouselInterval);
          carouselPage = 0;
          carouselStartTime = Date.now();
          carouselPhase = 'fadeIn'; // Start with fade in
          
          carouselInterval = setInterval(() => {
            const elapsed = Date.now() - carouselStartTime;
            const batchStart = carouselPage * displayRunsPerBatch;
            const batch = carouselRuns.slice(batchStart, batchStart + displayRunsPerBatch);
            
            if (carouselPhase === 'fadeIn') {
              // Phase de transition d'arrivee (0 vers 1)
              if (elapsed < CAROUSEL_FADE_DURATION) {
                const fadeProgress = elapsed / CAROUSEL_FADE_DURATION;
                draw(processedTop, batch, fadeProgress, processedPlayerRow);
              } else {
                carouselPhase = 'display';
                carouselStartTime = Date.now();
              }
            } else if (carouselPhase === 'display') {
              // Phase d'affichage stable (opacity = 1)
              if (elapsed < CAROUSEL_DISPLAY_DURATION) {
                draw(processedTop, batch, 1, processedPlayerRow);
              } else {
                carouselPhase = 'fadeOut';
                carouselStartTime = Date.now();
              }
            } else if (carouselPhase === 'fadeOut') {
              // Phase de transition de depart (1 vers 0)
              if (elapsed < CAROUSEL_FADE_DURATION) {
                const fadeProgress = 1 - (elapsed / CAROUSEL_FADE_DURATION);
                draw(processedTop, batch, fadeProgress, processedPlayerRow);
              } else {
                // Passage a la page suivante
                carouselPage = (carouselPage + 1) % Math.ceil(carouselRuns.length / displayRunsPerBatch);
                carouselPhase = 'fadeIn';
                carouselStartTime = Date.now();
              }
            }
          }, 16); // ~60 FPS
        }
      } catch (e) {
        console.error(e);
        draw([], [], 1, null);
      }
    }

    loadConfig();
    window.addEventListener('resize', loadTop);
  </script>
</body>
</html>