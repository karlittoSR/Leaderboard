<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elden Ring ‚Äì Any% Glitchless: Top 10 (Overlay)</title>
  <style>
    :root { --muted:#94a3b8; --text:#e2e8f0; }
    html, body { height: 100%; margin: 0; }
    body {
      background: transparent; /* twitch/karlitto__ */
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid; place-items: start; padding: 8px;
    }
    canvas { display:block; width:900px; height:174px; }
  </style>
</head>
<body>
  <canvas id="board" width="1200" height="400"></canvas>
  <script>
    // === Settings Loading ===
    // Variables loaded from settings file (config.json)
    let GAME_ID;
    let CATEGORY_NAME;
    let SUBCATEGORY_LABEL;
    let SUBCATEGORIES;
    let LEVEL_ID;
    let LEVEL_NAME;
    let PLAYER_NAME;
    let TEMPORARY_RUN;
    let CAROUSEL_INTERVAL;
    let RUNS_PER_BATCH;
    let TOP_COUNT;
    let MAX_RUNS;
    let FLAG_OVERRIDES;
    let USE_TROPHY_ICONS = false;
    let RANK_ALIGN = 'right';
    let RANK_PREFIX_MODE = 'dot';
    let NAME_SPACING = 4;
    let TIME_FORMAT = '1:25:25.255';
    let PB_SEPARATOR_WIDTH = null;
    let RAINBOW_INTENSITY = 50;

    // Trophy icon URLs (loaded from game assets)
    let TROPHY_1ST_URL = null;
    let TROPHY_2ND_URL = null;
    let TROPHY_3RD_URL = null;

    async function loadConfig() {
      try {
        // Load settings file (config.json)
        const configRes = await fetch('config.json');
        if (!configRes.ok) {
          throw new Error(`Impossible de charger config.json (HTTP ${configRes.status})`);
        }
        const config = await configRes.json();
        
        // Get the active preset from the settings file (no URL parameter needed)
        const presetName = config.activePreset;
        if (!presetName) {
          throw new Error('Aucun preset actif d√©fini dans config.json. Utilisez le script PowerShell pour en d√©finir un.');
        }
        
        const preset = config.presets[presetName];
        if (!preset) {
          const availablePresets = Object.keys(config.presets);
          throw new Error(`Preset actif "${presetName}" non trouv√©. Options disponibles : ${availablePresets.join(', ')}`);
        }

        // Apply preset settings
        GAME_ID = preset.gameId;
        CATEGORY_NAME = preset.category;
        SUBCATEGORY_LABEL = preset.subcategory;
        SUBCATEGORIES = preset.subcategories || null;
        if (SUBCATEGORIES && !Array.isArray(SUBCATEGORIES)) {
          SUBCATEGORIES = [SUBCATEGORIES];
        }
        LEVEL_ID = preset.levelId || null;
        LEVEL_NAME = preset.levelName || null;
        PLAYER_NAME = (config.playerName || '').trim();
        if (PLAYER_NAME === '') PLAYER_NAME = null;
        PLAYER_COUNTRY = (config.playerCountry || 'FR').trim().toUpperCase();
        if (PLAYER_COUNTRY.length !== 2) PLAYER_COUNTRY = 'FR'; // Fallback to FR if invalid

        const tempRun = config.temporaryRun || null;
        if (tempRun && tempRun.active && tempRun.time) {
          TEMPORARY_RUN = { time: String(tempRun.time).trim() };
        } else {
          TEMPORARY_RUN = null;
        }
        FLAG_OVERRIDES = config.flagOverrides || {};

        // Apply defaults from the settings file
        const defaults = config.defaults;
        CAROUSEL_INTERVAL = defaults.carouselInterval;
        CAROUSEL_DISPLAY_DURATION = CAROUSEL_INTERVAL - CAROUSEL_FADE_DURATION - CAROUSEL_FADE_DURATION;
        RUNS_PER_BATCH = defaults.runsPerBatch;
        TOP_COUNT = defaults.topCount;
        MAX_RUNS = Number.isFinite(defaults.maxRuns) ? defaults.maxRuns : 200;
        MAX_PLAYER_NAME_CHARS = defaults.maxNameWidthVisible || defaults.maxPlayerNameChars || 14;
        USE_TROPHY_ICONS = defaults.useTrophyIcons === true;
        const rankAlign = (defaults.rankAlign || 'right').toLowerCase();
        RANK_ALIGN = ['left', 'center', 'right'].includes(rankAlign) ? rankAlign : 'right';
        const rankPrefixMode = (defaults.rankPrefixMode || 'dot').toLowerCase();
        RANK_PREFIX_MODE = ['dot', 'hash'].includes(rankPrefixMode) ? rankPrefixMode : 'dot';
        const spacingValue = Number(defaults.nameSpacing);
        NAME_SPACING = Number.isFinite(spacingValue) ? Math.min(10, Math.max(0, spacingValue)) : 4;
        const timeFormatValue = String(defaults.timeFormat || '1:25:25.255').trim();
        TIME_FORMAT = (timeFormatValue === '1h25m25s225ms' || timeFormatValue === '1:25:25.255') ? timeFormatValue : '1:25:25.255';
        const pbSeparatorValue = Number(defaults.pbSeparatorWidth);
        PB_SEPARATOR_WIDTH = Number.isFinite(pbSeparatorValue) ? pbSeparatorValue : null;
        const rainbowValue = Number(defaults.rainbowIntensity);
        RAINBOW_INTENSITY = Number.isFinite(rainbowValue) ? Math.min(100, Math.max(0, rainbowValue)) : 50;

        // Apply Font Style
        const fontStyle = defaults.fontStyle || 'Arial';
        const fontMap = {
            'Arial': 'Arial, sans-serif',
            'Verdana': 'Verdana, Geneva, sans-serif',
            'TimesNewRoman': '"Times New Roman", Times, serif',
            'Georgia': 'Georgia, serif',
            'CourierNew': '"Courier New", Courier, monospace',
            'Impact': 'Impact, Charcoal, sans-serif',
            'TrebuchetMS': '"Trebuchet MS", Helvetica, sans-serif',
            'Tahoma': 'Tahoma, Geneva, sans-serif',
            'ComicSans': '"Comic Sans MS", "Comic Sans", cursive, sans-serif',
            'SegoeUI': '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif'
        };
        const selectedFontFamily = fontMap[fontStyle] || fontMap['Arial'];
        DRAW.FONT_BASE = '700 18px ' + selectedFontFamily;
        DRAW.FONT_MONO = '700 18px ' + selectedFontFamily;

        // Update title
        document.title = preset.name + ': Top ' + TOP_COUNT + ' (Overlay)';

        // Update overlay size from defaults
        canvas.width = defaults.canvasWidth;
        canvas.height = defaults.canvasHeight;
        canvas.style.width = defaults.displayWidth;
        canvas.style.height = defaults.displayHeight;

        // Start data load
        loadTop();
      } catch (e) {
        console.error('Erreur de configuration :', e);
        document.body.innerHTML = `<div style="color: red; padding: 20px; font-family: monospace;">‚ùå Erreur : ${e.message}</div>`;
      }
    }

    // === Overlay Setup ===
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    // Drawing constants
    const DRAW = {
      FLAG: { w: 20, h: 15, yOffset: 14, radius: 5 },
      TROPHY: { w: 20, h: 20, yOffset: 16, radius: 4 }, // Trophy icon dimensions
      LAYOUT: { padX: 12, startY: 30, rowH: 24 },
      FONT_BASE: '700 18px Arial, sans-serif',
      FONT_MONO: '700 18px Arial, sans-serif, SFMono-Regular, Menlo, Consolas, "Liberation Mono"',
      SHADOW: { color: 'rgba(0,0,0,0.6)', blur: 6, offsetY: 2 },
      COLORS: { top1: '#ffd700', top2: '#c0c0c0', top3: '#cd7f32', other: '#9fb4ca' }
    };

    // Image caches
    const imageCache = {
      flags: new Map(),
      trophies: new Map()
    };

    // Carousel state
    let carouselPage = 0;
    let carouselRuns = [];
    let carouselInterval = null;
    let carouselStartTime = 0;
    let carouselPhase = 'display'; // 'display', 'fadeOut', 'fadeIn'
    let CAROUSEL_FADE_DURATION = 500; // Fade transition duration (ms)
    let CAROUSEL_DISPLAY_DURATION = 3000; // Display duration (computed in loadConfig)

    let fixedMaxRankW = 0;
    let fixedMaxNameBlock = 0;
    let processedTopRuns = [];
    async function loadImage(url, cache, timeout = 5000) {
      if (!url) return null;
      if (cache.has(url)) return cache.get(url);
      
      return new Promise((resolve) => {
        const img = new Image();

        const timeoutId = setTimeout(() => {
          resolve(null);
        }, timeout);

        img.onload = () => {
          clearTimeout(timeoutId);
          cache.set(url, img);
          resolve(img);
        };

        img.onerror = () => {
          clearTimeout(timeoutId);
          resolve(null);
        };

        img.src = url;
      });
    }

    function loadFlagImage(code) {
      if (!code) return Promise.resolve(null);
      const url = `https://flagcdn.com/w40/${code.toLowerCase()}.png`;
      return loadImage(url, imageCache.flags);
    }

    function loadTrophyImage(url) {
      if (!url) return Promise.resolve(null);
      return loadImage(url, imageCache.trophies);
    }

    function normalizeCountry(code) {
      if (!code) return null;
      const key = String(code).toUpperCase();
      if (FLAG_OVERRIDES && Object.prototype.hasOwnProperty.call(FLAG_OVERRIDES, key)) {
        const override = FLAG_OVERRIDES[key];
        if (!override) return null;
        return String(override).toUpperCase();
      }
      return key;
    }

    function isRunRecent(submittedDate) {
      if (!submittedDate) return false;
      const date = new Date(submittedDate);
      if (isNaN(date.getTime())) return false;
      const now = new Date();
      const diffMs = now - date;
      const diffDays = diffMs / (1000 * 60 * 60 * 24);
      return diffDays < 5;
    }

    // === Utilities ===
    function drawRoundedImage(img, x, y, w, h, r) {
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x, y, w, h);
      ctx.restore();
    }

    function formatTime(sec) {
      const total = Number(sec);
      if (TIME_FORMAT === '1h25m25s225ms') {
        const totalMs = Math.round(Number(sec) * 1000);
        const absMs = Math.max(0, totalMs);
        
        const h = Math.floor(absMs / 3600000);
        const remainderH = absMs % 3600000;
        
        const m = Math.floor(remainderH / 60000);
        const remainderM = remainderH % 60000;
        
        const s = Math.floor(remainderM / 1000);
        const ms = remainderM % 1000;

        const parts = [];
        
        // Hours (only if > 0)
        if (h > 0) { 
            parts.push(`${h}h`); 
        }
        
        // Minutes (if hours exist, pad with 0, else only if > 0)
        if (h > 0) {
            parts.push(`${String(m).padStart(2, '0')}m`);
        } else if (m > 0) {
            parts.push(`${m}m`);
        }
        
        // Seconds (always show, pad if minutes or hours exist)
        if (h > 0 || m > 0) {
            parts.push(`${String(s).padStart(2, '0')}s`);
        } else {
            parts.push(`${s}s`);
        }
        
        // Milliseconds: always padded 3 digits if present (e.g. 036ms)
        if (ms > 0) { 
            parts.push(`${String(ms).padStart(3, '0')}ms`); 
        }
        
        return parts.join(' ');
      }
      
      const h = Math.floor(Number(sec) / 3600);
      const m = Math.floor((Number(sec) % 3600) / 60);
      const s = Number(sec) % 60;
      
      // Check if we have milliseconds (non-integer seconds)
      const hasMilliseconds = s !== Math.floor(s);
      
      if (hasMilliseconds) {
        // Format with milliseconds (up to 3 decimal places)
        const secondsInt = Math.floor(s);
        const milliseconds = Math.round((s - secondsInt) * 1000);
        const sFormatted = `${String(secondsInt).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
        const mm = String(m).padStart(2, '0');
        return h > 0 ? `${h}:${mm}:${sFormatted}` : `${m}:${sFormatted}`;
      } else {
        // Format without milliseconds
        const sInt = Math.floor(s);
        const mm = String(m).padStart(2, '0');
        const ss = String(sInt).padStart(2, '0');
        return h > 0 ? `${h}:${mm}:${ss}` : `${m}:${ss}`;
      }
    }

    function parseTimeString(text) {
      if (!text) return null;
      const clean = String(text).trim().replace(',', '.');
      if (!clean) return null;
      if (/^\d+(\.\d+)?$/.test(clean)) {
        const val = Number(clean);
        return Number.isFinite(val) ? val : null;
      }
      const parts = clean.split(':');
      if (parts.length < 2 || parts.length > 3) return null;
      const nums = parts.map(p => Number(p));
      if (nums.some(n => !Number.isFinite(n) || n < 0)) return null;
      let hours = 0;
      let minutes = 0;
      let seconds = 0;
      if (nums.length === 2) {
        [minutes, seconds] = nums;
      } else {
        [hours, minutes, seconds] = nums;
        if (minutes >= 60) return null;
      }
      if (seconds >= 60) return null;
      return (hours * 3600) + (minutes * 60) + seconds;
    }

    function getRankColor(position) {
      return [DRAW.COLORS.top1, DRAW.COLORS.top2, DRAW.COLORS.top3, DRAW.COLORS.other][Math.min(position, 3)];
    }

    function getTemporaryColor() {
      return '#00e5ff';
    }

    function truncatePlayer(name, maxChars = null) {
      if (maxChars === null) {
        maxChars = MAX_PLAYER_NAME_CHARS || 14;
      }
      return name.length > maxChars ? 'W'.repeat(maxChars) : name;
    }

    function drawScrollingText(ctx, text, x, y, maxWidth, style, isTemporary, rainbowPhase, fontBase) {
      if (!text) return;
      
      ctx.save();
      if (fontBase) ctx.font = fontBase;
      const textWidth = ctx.measureText(text).width;
      ctx.restore();
      
      // If text fits, draw normally
      if (textWidth <= maxWidth) {
        if (isTemporary) {
          applyRainbowText(x, y, text, rainbowPhase);
          ctx.textAlign = 'left';
          ctx.fillText(text, x, y);
        } else {
          ctx.fillStyle = DRAW.COLORS.other;
          applyTextStyle(x, y, text, style);
          ctx.textAlign = 'left';
          ctx.fillText(text, x, y);
        }
        return;
      }

      // Scrolling logic (Marquee loop)
      const speed = 30; // pixels per second
      const gap = 20;   // gap between loops
      const loopDist = textWidth + gap;
      const totalTime = (loopDist / speed) * 1000;
      const offset = (Date.now() % totalTime) / totalTime * loopDist;
      
      ctx.save();
      if (fontBase) ctx.font = fontBase;
      ctx.beginPath();
      // Clip rectangle: x, y-ascent, width, height
      // Assuming font size ~18px, baseline at y. extend up 18 and down 6
      ctx.rect(x, y - 18, maxWidth, 26); 
      ctx.clip();
      
      const drawInstance = (currentX) => {
         if (isTemporary) {
             applyRainbowText(currentX, y, text, rainbowPhase);
             ctx.textAlign = 'left';
             ctx.fillText(text, currentX, y);
         } else {
             // For gradient, we need to regenerate execution relative to currentX if desired, 
             // but applyTextStyle uses ctx.createLinearGradient(x, ... x+width).
             // We should pass currentX to applyTextStyle.
             
             ctx.fillStyle = DRAW.COLORS.other;
             applyTextStyle(currentX, y, text, style);
             ctx.textAlign = 'left';
             ctx.fillText(text, currentX, y);
         }
      };

      // Draw two instances for seamless loop
      // Instance 1
      drawInstance(x - offset);
      // Instance 2
      drawInstance(x - offset + loopDist);
      
      ctx.restore();
    }

    function applyTextStyle(x, y, text, style) {
      if (!style || style.style === 'solid') {
        ctx.fillStyle = style?.color?.dark || style?.color?.light || '#e2e8f0';
        return;
      }
      if (style.style === 'gradient') {
        const from = style['color-from']?.dark || '#e2e8f0';
        const to = style['color-to']?.dark || '#e2e8f0';
        const width = ctx.measureText(text).width;
        const grad = ctx.createLinearGradient(x, y, x + width, y);
        grad.addColorStop(0, from);
        grad.addColorStop(1, to);
        ctx.fillStyle = grad;
        return;
      }
      ctx.fillStyle = '#e2e8f0';
    }

    function hslToRgb(h, s, l) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;

      if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
      else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
      else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
      else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
      else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }

      const rr = Math.round((r + m) * 255);
      const gg = Math.round((g + m) * 255);
      const bb = Math.round((b + m) * 255);
      return `rgb(${rr}, ${gg}, ${bb})`;
    }

    function applyRainbowText(x, y, text, phase, alpha = 1) {
      const hue = phase % 360;
      const intensity = Math.min(1, Math.max(0, RAINBOW_INTENSITY / 100));
      const saturation = 0.15 + (0.85 * intensity);
      ctx.fillStyle = hslToRgb(hue, saturation, 0.7);
    }

    function getRankTextAlign() {
      if (RANK_ALIGN === 'left') return 'left';
      if (RANK_ALIGN === 'center') return 'center';
      return 'right';
    }

    function getRankTextX(colRank) {
      if (RANK_ALIGN === 'left') return colRank;
      if (RANK_ALIGN === 'center') return colRank + (fixedMaxRankW / 2);
      return colRank + fixedMaxRankW;
    }

    function getRankIconX(colRank, iconWidth) {
      if (RANK_ALIGN === 'left') return colRank;
      if (RANK_ALIGN === 'center') return colRank + (fixedMaxRankW - iconWidth) / 2;
      return colRank + fixedMaxRankW - iconWidth;
    }

    // === Draw ===
    function draw(topRuns, carouselBatch, fadeProgress = 1, playerRow = null) {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx.shadowColor = DRAW.SHADOW.color;
      ctx.shadowBlur = DRAW.SHADOW.blur;
      ctx.shadowOffsetY = DRAW.SHADOW.offsetY;
      ctx.font = DRAW.FONT_BASE;
      ctx.textAlign = 'left';

      const allDisplay = [...topRuns, ...carouselBatch];
      const phaseBase = (Date.now() / 30) % 360;
      const { padX, startY, rowH } = DRAW.LAYOUT;
      const colRank = padX;
      const timeX = Math.min(350, canvas.clientWidth - padX); // Right aligned

      for (let i = 0; i < allDisplay.length; i++) {
        const r = allDisplay[i];
        const y = startY + i * rowH;
        // Reset font to base for each row
        ctx.font = DRAW.FONT_BASE;
        const isTemporary = !!r.isTemporary;
        const isRecent = isRunRecent(r.submitted);
        const useRainbow = isTemporary || isRecent;
        const color = getRankColor(r.rank - 1);  // Use actual rank for color (supports ties)

        // Apply fade only to carousel rows (rows 3-7, indices 3-7)
        const isCarouselRow = i >= TOP_COUNT;
        const globalAlpha = ctx.globalAlpha;
        if (isCarouselRow && fadeProgress < 1) {
          ctx.globalAlpha = fadeProgress;
        }

        // Draw rank (trophy for top 3, # + number for others)
        if (USE_TROPHY_ICONS && r.trophyImg && r.rank >= 1 && r.rank <= 3) {
          // Draw trophy icon for top 3 (centered in rank column)
          drawRoundedImage(
            r.trophyImg,
            getRankIconX(colRank, DRAW.TROPHY.w),
            y - DRAW.TROPHY.yOffset,
            DRAW.TROPHY.w,
            DRAW.TROPHY.h,
            DRAW.TROPHY.radius  // slight rounding
          );
        } else {
          // Draw number right-aligned
          let rankText = `${r.rank}`;
          if (typeof r.rank === 'number' && r.rank > 0) {
            rankText = (RANK_PREFIX_MODE === 'hash') ? `#${r.rank}` : `${r.rank}.`;
          }
          const rankX = getRankTextX(colRank);
          ctx.textAlign = getRankTextAlign();
          if (useRainbow) {
            applyRainbowText(rankX, y, rankText, phaseBase + i * 12);
          } else {
            ctx.fillStyle = color;
          }
          ctx.fillText(rankText, rankX, y);
        }

        // Draw flag + name
        let x = colRank + fixedMaxRankW + NAME_SPACING;
        if (r.flagImg) {
          drawRoundedImage(r.flagImg, x, y - DRAW.FLAG.yOffset, DRAW.FLAG.w, DRAW.FLAG.h, DRAW.FLAG.radius);
        } else {
           // Default flag (Globe)
           ctx.save();
           ctx.font = '16px sans-serif'; // Adapted size for the flag box
           ctx.textAlign = 'center';
           ctx.textBaseline = 'middle';
           ctx.fillText('üåé', x + DRAW.FLAG.w / 2, y - 6);
           ctx.restore();
        }
        x += DRAW.FLAG.w + NAME_SPACING; // Keep space even when there is no flag, to make names aligned.

        // Calculate available width for name using the configured maxNameWidthVisible
        // Use fixedMaxNameBlock (which we calculated using MAX_PLAYER_NAME_CHARS) as the base constraint
        // But also ensure we don't overlap time (responsive shrinking is still okay)
        
        ctx.save();
        ctx.font = DRAW.FONT_MONO;
        const timeWidth = ctx.measureText(r.time).width;
        ctx.restore();

        // The maximum standard width allowed by configuration (excluding flag width part of fixedMaxNameBlock)
        // fixedMaxNameBlock includes flag width + name, so we subtract flag width to get "max configured name width"
        const currentFlagW = DRAW.FLAG.w + NAME_SPACING;
        const configuredMaxNameWidth = Math.max(50, fixedMaxNameBlock - currentFlagW);

        // The absolute available space on screen before hitting the time
        const screenSpaceAvailable = timeX - timeWidth - x - 12; // 12px padding

        // Use the smaller of the two: respect config, but shrink if screen is too small
        const availableWidth = Math.min(configuredMaxNameWidth, screenSpaceAvailable);

        const rawName = isTemporary ? `PB - ${r.player}` : r.player;
        drawScrollingText(ctx, rawName, x, y, availableWidth, r.nameStyle, useRainbow, phaseBase + 40 + i * 12, DRAW.FONT_BASE);

        // Draw time (right-aligned)
        ctx.font = DRAW.FONT_MONO;
        ctx.fillStyle = color;
        
        ctx.textAlign = 'right';
        if (useRainbow) {
          applyRainbowText(timeX - ctx.measureText(r.time).width, y, r.time, phaseBase + 80 + i * 12);
          ctx.fillText(r.time, timeX, y);
        } else {
          ctx.fillText(r.time, timeX, y);
        }

        ctx.globalAlpha = globalAlpha;
      }

      if (playerRow) {
        const gap = rowH; // One clear blank row
        const canvasH = canvas.clientHeight;
        const desiredY = startY + allDisplay.length * rowH + gap;
        const y = Math.min(desiredY, canvasH - rowH);
        const phase = (Date.now() / 30) % 360;
        const isTemporary = !!playerRow.isTemporary;
        const isRecent = isRunRecent(playerRow.submitted);
        const useRainbow = isTemporary || isRecent;

        // Separator line instead of an empty gap
        const lineY = startY + allDisplay.length * rowH - 4;
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const areaStartX = padX + 6;
        const areaEndX = Math.min(timeX - 6, canvas.clientWidth - padX);
        const maxBarWidth = Math.max(0, areaEndX - areaStartX);
        let barWidth = Number.isFinite(PB_SEPARATOR_WIDTH) ? PB_SEPARATOR_WIDTH : maxBarWidth;
        if (maxBarWidth < 50) {
          barWidth = maxBarWidth;
        } else {
          barWidth = Math.min(Math.max(barWidth, 50), maxBarWidth);
        }
        const lineStartX = areaStartX + (maxBarWidth - barWidth) / 2;
        const lineEndX = lineStartX + barWidth;
        ctx.moveTo(lineStartX, lineY);
        ctx.lineTo(lineEndX, lineY);
        ctx.stroke();
        ctx.restore();

        // Reset font to base
        ctx.font = DRAW.FONT_BASE;

        // Draw rank (trophy for top 3, # + number for others)
        if (USE_TROPHY_ICONS && playerRow.trophyImg && playerRow.rank >= 1 && playerRow.rank <= 3) {
          // Draw trophy icon for top 3 (centered in rank column)
          drawRoundedImage(
            playerRow.trophyImg,
            getRankIconX(colRank, DRAW.TROPHY.w),
            y - DRAW.TROPHY.yOffset,
            DRAW.TROPHY.w,
            DRAW.TROPHY.h,
            4
          );
        } else {
          // Draw number right-aligned
          let rankText = `${playerRow.rank}`;
          if (typeof playerRow.rank === 'number' && playerRow.rank > 0) {
            rankText = (RANK_PREFIX_MODE === 'hash') ? `#${playerRow.rank}` : `${playerRow.rank}.`;
          }
          const rankX = getRankTextX(colRank);
          ctx.textAlign = getRankTextAlign();
          if (useRainbow) {
            applyRainbowText(rankX, y, rankText, phase);
          } else {
            ctx.fillStyle = DRAW.COLORS.other;
          }
          ctx.fillText(rankText, rankX, y);
        }

        let x = colRank + fixedMaxRankW + NAME_SPACING;
        if (playerRow.flagImg) {
          drawRoundedImage(playerRow.flagImg, x, y - DRAW.FLAG.yOffset, DRAW.FLAG.w, DRAW.FLAG.h, DRAW.FLAG.radius);
        } else {
           // Default flag (Globe)
           ctx.save();
           ctx.font = '16px sans-serif'; 
           ctx.textAlign = 'center';
           ctx.textBaseline = 'middle';
           ctx.fillText('üåé', x + DRAW.FLAG.w / 2, y - 6);
           ctx.restore();
        }
        x += DRAW.FLAG.w + NAME_SPACING; // Keep space even when there is no flag, to make names aligned.

        // Calculate available width for name using the configured maxNameWidthVisible
        // Use fixedMaxNameBlock (which we calculated using MAX_PLAYER_NAME_CHARS) as the base constraint
        // But also ensure we don't overlap time (responsive shrinking is still okay)
        
        ctx.save();
        ctx.font = DRAW.FONT_MONO;
        const timeWidth = ctx.measureText(playerRow.time).width;
        ctx.restore();

        // The maximum standard width allowed by configuration
        const currentFlagW = DRAW.FLAG.w + NAME_SPACING;
        const configuredMaxNameWidth = Math.max(50, fixedMaxNameBlock - currentFlagW);

        // The absolute available space on screen before hitting the time
        const screenSpaceAvailable = timeX - timeWidth - x - 12; // 12px padding

        // Use the smaller of the two
        const availableWidth = Math.min(configuredMaxNameWidth, screenSpaceAvailable);

        const rawName = isTemporary ? `PB - ${playerRow.player}` : playerRow.player;
        drawScrollingText(ctx, rawName, x, y, availableWidth, playerRow.nameStyle, useRainbow, phase + 40, DRAW.FONT_BASE);

        ctx.font = DRAW.FONT_MONO;
        ctx.textAlign = 'right';
        if (useRainbow) {
          applyRainbowText(timeX - ctx.measureText(playerRow.time).width, y, playerRow.time, phase + 80);
          ctx.fillText(playerRow.time, timeX, y);
        } else {
          ctx.fillStyle = DRAW.COLORS.other;
          ctx.fillText(playerRow.time, timeX, y);
        }
        ctx.globalAlpha = 1;
      }

      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;
    }

    // === Data processing ===
    async function fetchJSON(url, timeout = 10000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const r = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (!r.ok) throw new Error(`HTTP ${r.status} pour ${url}`);
        return r.json();
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          throw new Error(`Delai d'attente depasse (${timeout}ms) pour ${url}`);
        }
        throw error;
      }
    }

    async function resolveCategoryAndVariable() {
      const url = `https://www.speedrun.com/api/v1/games/${GAME_ID}?embed=categories.variables`;
      const data = await fetchJSON(url);
      const cats = data.data.categories.data;
      const targetType = LEVEL_ID ? 'per-level' : 'per-game';
      const cat = cats.find(c => c.type === targetType && c.name === CATEGORY_NAME);
      if (!cat) throw new Error(`Categorie "${CATEGORY_NAME}" non trouvee (options : ${cats.map(c => c.name).join(', ')})`);
      
      const vars = (cat.variables?.data) || [];

      // New structure: list of subcategory IDs
      if (Array.isArray(SUBCATEGORIES) && SUBCATEGORIES.length > 0) {
        const usedVars = new Set();
        const variablePairs = [];

        for (const entry of SUBCATEGORIES) {
          if (!entry) continue;
          let matched = null;

          if (entry.variableId && entry.valueId) {
            const variable = vars.find(v => v.id === entry.variableId);
            if (variable && variable.values?.values && variable.values.values[entry.valueId]) {
              matched = { variableId: entry.variableId, valueId: entry.valueId };
              usedVars.add(entry.variableId);
            }
          }

          if (!matched && entry.label) {
            const targetLabel = String(entry.label).toLowerCase();
            const variable = vars.find(v => v['is-subcategory'] && !usedVars.has(v.id) && v.values?.values &&
              Object.values(v.values.values).some(val => (val.label || '').toLowerCase() === targetLabel));
            if (variable) {
              const valueEntry = Object.entries(variable.values.values)
                .find(([, value]) => (value.label || '').toLowerCase() === targetLabel);
              if (valueEntry) {
                matched = { variableId: variable.id, valueId: valueEntry[0] };
                usedVars.add(variable.id);
              }
            }
          }

          if (matched) {
            variablePairs.push(matched);
          }
        }

        if (variablePairs.length > 0) {
          return { categoryId: cat.id, variablePairs };
        }
      }

      // No subcategory required
      if (!SUBCATEGORY_LABEL) {
        return { categoryId: cat.id, variablePairs: [] };
      }

      const labels = SUBCATEGORY_LABEL.split(' - ').map(s => s.trim()).filter(Boolean);
      const usedVars = new Set();
      const variablePairs = [];

      for (const label of labels) {
        const sub = vars.find(v => v['is-subcategory'] && v.values?.values && !usedVars.has(v.id) &&
          Object.values(v.values.values).some(val => val.label.toLowerCase() === label.toLowerCase()));
        if (!sub) throw new Error(`Sous-categorie "${label}" non trouvee pour "${CATEGORY_NAME}"`);

        const entry = Object.entries(sub.values.values)
          .find(([, value]) => value.label.toLowerCase() === label.toLowerCase());
        if (!entry) throw new Error(`Valeur "${label}" non trouvee`);

        const [valueId] = entry;
        variablePairs.push({ variableId: sub.id, valueId });
        usedVars.add(sub.id);
      }

      return { categoryId: cat.id, variablePairs };
    }

    function calculateColumnWidths(allRuns, playerRow) {
      ctx.font = DRAW.FONT_BASE;

      let maxRankW = 0;
      let maxNameBlock = 0;
      const trophyWidth = DRAW.TROPHY.w;  // Width for trophy icons

      const widthRuns = playerRow ? [...allRuns, playerRow] : allRuns;
      for (const r of widthRuns) {
        // Trophy takes fixed width for top 3
        if (r.rank >= 1 && r.rank <= 3 && USE_TROPHY_ICONS) {
          maxRankW = Math.max(maxRankW, trophyWidth);
        } else {
          // Text width for rank 4+
          let rankText = `${r.rank}`;
          if (typeof r.rank === 'number' && r.rank > 0) {
            rankText = (RANK_PREFIX_MODE === 'hash') ? `#${r.rank}` : `${r.rank}.`;
          }
          const numberW = ctx.measureText(rankText).width;
          maxRankW = Math.max(maxRankW, numberW);
        }

        // Name block width (flag + truncated name)
        const flagW = r.flagImg ? DRAW.FLAG.w + NAME_SPACING : 0;
        const truncatedName = truncatePlayer(r.player);
        const nameW = ctx.measureText(truncatedName).width;
        maxNameBlock = Math.max(maxNameBlock, flagW + nameW);
      }

      // Ensure minimum width based on configured MAX_PLAYER_NAME_CHARS
      const configuredMaxName = 'W'.repeat(MAX_PLAYER_NAME_CHARS || 14);
      const configuredMaxWidth = ctx.measureText(configuredMaxName).width;
      const maxFlagW = DRAW.FLAG.w + NAME_SPACING;
      const minConfiguredBlock = maxFlagW + configuredMaxWidth;
      
      // Use the larger of actual data width or configured minimum width
      maxNameBlock = Math.max(maxNameBlock, minConfiguredBlock);

      // Total rank width: max of trophy width OR number width
      fixedMaxRankW = Math.max(trophyWidth, maxRankW);
      fixedMaxNameBlock = maxNameBlock;
    }

    async function loadTop() {
      try {
        const { categoryId, variablePairs } = await resolveCategoryAndVariable();
        
        // Build leaderboard URL
        let lbUrl;
        const limit = Math.max(TOP_COUNT, MAX_RUNS || 0);
        const embedParams = USE_TROPHY_ICONS ? 'game,players' : 'players';
        if (LEVEL_ID) {
          lbUrl = `https://www.speedrun.com/api/v1/leaderboards/${GAME_ID}/level/${LEVEL_ID}/${categoryId}?top=${limit}&embed=${embedParams}`;
        } else {
          lbUrl = `https://www.speedrun.com/api/v1/leaderboards/${GAME_ID}/category/${categoryId}?top=${limit}&embed=${embedParams}`;
        }
        if (Array.isArray(variablePairs) && variablePairs.length > 0) {
          for (const pair of variablePairs) {
            if (pair.variableId && pair.valueId) {
              lbUrl += `&var-${pair.variableId}=${pair.valueId}`;
            }
          }
        }
        
        const lb = await fetchJSON(lbUrl);

        // Extract trophy URLs from embedded game data (only if trophy icons enabled)
        if (USE_TROPHY_ICONS && lb.data.game?.data?.assets) {
          const assets = lb.data.game.data.assets;
          TROPHY_1ST_URL = assets['trophy-1st']?.uri || null;
          TROPHY_2ND_URL = assets['trophy-2nd']?.uri || null;
          TROPHY_3RD_URL = assets['trophy-3rd']?.uri || null;
        }

        // Build player map
        const playerMap = new Map();
        if (lb.data.players?.data) {
          for (const player of lb.data.players.data) {
            const displayName = player.rel === 'guest' ? player.name : (player.names?.international || player.id);
            playerMap.set(player.id, {
              name: displayName,
              style: player['name-style'] || null,
              country: player.location?.country?.code || null
            });
          }
        }

        // Process runs
        const allRuns = (lb.data.runs || []).map((entry) => {
          const run = entry.run;
          const players = (run.players || []).map((p) => {
            if (p.rel === 'guest') return p.name;
            const info = playerMap.get(p.id);
            return info ? info.name : p.id;
          });

          const firstPlayer = run.players?.[0];
          const playerInfo = firstPlayer && firstPlayer.rel !== 'guest'
            ? (playerMap.get(firstPlayer.id) || { name: players[0] || 'Inconnu', style: null, country: null })
            : { name: players[0] || 'Inconnu', style: null, country: null };

          const timeSeconds = Number.isFinite(run.times?.primary_t) ? run.times.primary_t : 0;
          return {
            rank: entry.place || 0,
            player: playerInfo.name,
            players,
            nameStyle: playerInfo.style,
            country: normalizeCountry(playerInfo.country),
            time: formatTime(timeSeconds),
            timeSeconds,
            submitted: run.submitted
          };
        });

        if (PLAYER_NAME && TEMPORARY_RUN && TEMPORARY_RUN.time) {
          const target = PLAYER_NAME.toLowerCase();
          const matchIndex = allRuns.findIndex(r => (r.players || []).some(n => n.toLowerCase() === target));
          if (matchIndex >= 0) {
            const tempSeconds = parseTimeString(TEMPORARY_RUN.time);
            if (Number.isFinite(tempSeconds)) {
              allRuns[matchIndex] = {
                ...allRuns[matchIndex],
                player: PLAYER_NAME,
                players: [PLAYER_NAME],
                timeSeconds: tempSeconds,
                time: formatTime(tempSeconds),
                isTemporary: true
              };
            }
          } else {
             // Player not found in loaded runs, but we have a temporary PB.
             // Add them as a new entry so they appear in the ranking logic.
             const tempSeconds = parseTimeString(TEMPORARY_RUN.time);
             if (Number.isFinite(tempSeconds)) {
                 allRuns.push({
                     rank: 0, 
                     player: PLAYER_NAME,
                     players: [PLAYER_NAME],
                     nameStyle: null,
                     country: normalizeCountry(PLAYER_COUNTRY),
                     time: formatTime(tempSeconds),
                     timeSeconds: tempSeconds,
                     submitted: new Date().toISOString(),
                     isTemporary: true
                 });
             }
          }
        }

        let sortedRuns = allRuns
          .map((r, idx) => ({ ...r, _idx: idx }))
          .sort((a, b) => {
            const aTime = Number.isFinite(a.timeSeconds) ? a.timeSeconds : Number.POSITIVE_INFINITY;
            const bTime = Number.isFinite(b.timeSeconds) ? b.timeSeconds : Number.POSITIVE_INFINITY;
            if (aTime !== bTime) return aTime - bTime;
            return a._idx - b._idx;
          });

        // Assign ranks with tie handling (same time = same rank)
        let lastTime = null;
        let lastRank = 0;
        sortedRuns = sortedRuns.map((r, idx) => {
          const copy = { ...r };
          delete copy._idx;
          if (r.timeSeconds === lastTime) {
            copy.rank = lastRank;
          } else {
            copy.rank = idx + 1;
            lastRank = copy.rank;
            lastTime = r.timeSeconds;
          }
          return copy;
        });

        let playerRow = null;
        if (PLAYER_NAME) {
          const target = PLAYER_NAME.toLowerCase();
          const match = sortedRuns.find(r => (r.players || []).some(n => n.toLowerCase() === target));
          if (match) {
            const isInTop = typeof match.rank === 'number' && match.rank >= 1 && match.rank <= TOP_COUNT;
            if (!isInTop) {
              playerRow = { ...match, player: PLAYER_NAME };
            }
          }
        }

        // Split into top N and carousel
        const topRuns = sortedRuns.slice(0, TOP_COUNT);
        carouselRuns = sortedRuns.slice(TOP_COUNT, Math.max(TOP_COUNT, MAX_RUNS || 0));
        carouselPage = 0;

        // Load flag images
        const countryCodes = Array.from(new Set(sortedRuns.map(r => r.country).filter(Boolean)));
        await Promise.allSettled(countryCodes.map(loadFlagImage));
        
        const flagMap = new Map();
        for (const code of countryCodes) {
          const key = code.toLowerCase();
          const flagUrl = `https://flagcdn.com/w40/${key}.png`;
          flagMap.set(code, imageCache.flags.get(flagUrl) || null);
        }
        console.log(`Drapeaux charges : ${countryCodes.length}`);

        // Load trophy images (only if trophy icons enabled)
        let trophyMap = { 1: null, 2: null, 3: null };
        if (USE_TROPHY_ICONS) {
          const trophyUrls = [TROPHY_1ST_URL, TROPHY_2ND_URL, TROPHY_3RD_URL].filter(Boolean);
          await Promise.allSettled(trophyUrls.map(url => loadTrophyImage(url)));
          console.log(`Trophy images loaded: ${trophyUrls.length}`);

          // Build trophy image map
          trophyMap = {
            1: TROPHY_1ST_URL ? imageCache.trophies.get(TROPHY_1ST_URL) : null,
            2: TROPHY_2ND_URL ? imageCache.trophies.get(TROPHY_2ND_URL) : null,
            3: TROPHY_3RD_URL ? imageCache.trophies.get(TROPHY_3RD_URL) : null
          };
        }

        const processRuns = (runs) => runs.map(r => ({
          ...r,
          flagImg: flagMap.get(r.country) || null,
          trophyImg: trophyMap[r.rank] || null  // Add trophy image for top 3
        }));

        const processedTop = processRuns(topRuns);
        carouselRuns = processRuns(carouselRuns);
        const processedPlayerRow = playerRow ? {
          ...playerRow,
          flagImg: flagMap.get(playerRow.country) || null,
          trophyImg: trophyMap[playerRow.rank] || null
        } : null;

        // Store for carousel
        processedTopRuns = processedTop;

        // Calculate fixed widths
        calculateColumnWidths(sortedRuns, processedPlayerRow);

        // Draw and start carousel
        const availableRows = Math.floor((canvas.clientHeight - DRAW.LAYOUT.startY) / DRAW.LAYOUT.rowH);
        const extraRows = processedPlayerRow ? 2 : 0; // blank row + player row
        const neededRows = TOP_COUNT + RUNS_PER_BATCH + extraRows;
        const overflow = Math.max(0, neededRows - availableRows);
        const displayRunsPerBatch = Math.max(0, RUNS_PER_BATCH - overflow);
        const firstBatch = displayRunsPerBatch > 0 ? carouselRuns.slice(0, displayRunsPerBatch) : [];
        draw(processedTop, firstBatch, 1, processedPlayerRow);

        if (carouselRuns.length > 0 && displayRunsPerBatch > 0) {
          if (carouselInterval) clearInterval(carouselInterval);
          carouselPage = 0;
          carouselStartTime = Date.now();
          carouselPhase = 'fadeIn'; // Start with fade in
          
          carouselInterval = setInterval(() => {
            const elapsed = Date.now() - carouselStartTime;
            const batchStart = carouselPage * displayRunsPerBatch;
            const batch = carouselRuns.slice(batchStart, batchStart + displayRunsPerBatch);
            
            if (carouselPhase === 'fadeIn') {
              // Fade-in transition phase (0 to 1)
              if (elapsed < CAROUSEL_FADE_DURATION) {
                const fadeProgress = elapsed / CAROUSEL_FADE_DURATION;
                draw(processedTop, batch, fadeProgress, processedPlayerRow);
              } else {
                carouselPhase = 'display';
                carouselStartTime = Date.now();
              }
            } else if (carouselPhase === 'display') {
              // Stable display phase (opacity = 1)
              if (elapsed < CAROUSEL_DISPLAY_DURATION) {
                draw(processedTop, batch, 1, processedPlayerRow);
              } else {
                carouselPhase = 'fadeOut';
                carouselStartTime = Date.now();
              }
            } else if (carouselPhase === 'fadeOut') {
              // Fade-out transition phase (1 to 0)
              if (elapsed < CAROUSEL_FADE_DURATION) {
                const fadeProgress = 1 - (elapsed / CAROUSEL_FADE_DURATION);
                draw(processedTop, batch, fadeProgress, processedPlayerRow);
              } else {
                // Move to the next page
                carouselPage = (carouselPage + 1) % Math.ceil(carouselRuns.length / displayRunsPerBatch);
                carouselPhase = 'fadeIn';
                carouselStartTime = Date.now();
              }
            }
          }, 16); // ~60 FPS
        }
      } catch (e) {
        console.error(e);
        draw([], [], 1, null);
      }
    }

    loadConfig();
    window.addEventListener('resize', loadTop);
  </script>
</body>
</html>